# tshark 命令配置文件
# 格式: 命令模板::输出文件名后缀::协议标识
# 命令模板中使用 {INPUT} 作为输入文件占位符
# 使用 :: 作为分隔符（避免与命令中的管道符 | 冲突）
# 空行和以 # 开头的行将被忽略
# 执行顺序按照配置文件中从上至下的顺序
# 输出文件名格式: <序号>-<后缀>，序号从 1 开始自动递增
#
# 协议标识说明：
# - 留空或使用 "all" 表示总是执行（不依赖协议检测）
# - 指定协议名（如 tcp, udp, dns）表示仅当 pcap 中包含该协议时才执行
# - 可以指定多个协议，用逗号分隔（如 tcp,ip）表示任一协议存在即执行
# - 协议名不区分大小写
#
# 格式示例：
# tshark -r {INPUT} -q -z io,phs::protocol-hierarchy.txt::all
# tshark -r {INPUT} -q -z conv,tcp::tcp-conversations.txt::tcp

# 协议分布统计 - 总是执行（用于检测协议）
tshark -r {INPUT} -q -z io,phs::protocol-hierarchy.txt::all

# IPv4 相关统计
tshark -r {INPUT} -q -z conv,ip::ipv4-conversations.txt::ip
tshark -r {INPUT} -q -z ip_ttl,tree::ipv4-source-ttls.txt::ip
tshark -r {INPUT} -q -z dests,tree::ipv4-destinations-and-ports.txt::ip

# TCP 相关统计
tshark -r {INPUT} -q -z conv,tcp::tcp-conversations.txt::tcp
tshark -r {INPUT} -Y "tcp.analysis.zero_window" -T fields -e ip.src -e tcp.srcport -e ip.dst -e tcp.dstport | sort | uniq -c | sort -nr | awk 'BEGIN {print "Zero Window Count\nCount\tSrcIP\tSrcPort\tDstIP\tDstPort"} {print $1"\t"$2"\t"$3"\t"$4"\t"$5}'::tcp-zero-window.txt::tcp
tshark -r {INPUT} -q -z conv,tcp | awk -v bins="1,5,10,30,60" 'BEGIN{n=split(bins,a,",");for(i=1;i<=n;i++)b[i]=a[i]+0} match($0,/^([^ ]+):([0-9]+)[[:space:]]+<->[[:space:]]+([^ ]+):([0-9]+).* ([0-9]+(\.[0-9]+)?)$/,m){src=m[1];sp=m[2];dst=m[3];dp=m[4];dur=m[5]+0;bucket=">="b[n]"s";for(i=1;i<=n;i++)if(dur<b[i]){bucket="<"b[i]"s";break}cnt[bucket]++;list[bucket]=list[bucket]sprintf("%s,%s,%s,%s,TCP,%.3fs\n",src,sp,dst,dp,dur)}END{ord[++x]=">="b[n]"s";for(i=n;i>=1;i--)ord[++x]="<"b[i]"s";for(j=1;j<=x;j++){k=ord[j];printf("Bucket %s: %d connections\n",k,cnt[k]+0);if(cnt[k]>0)printf("%s",list[k]);print""}}'::tcp-connection-duration.txt::tcp
tshark -2 -r {INPUT} -Y tcp -T fields -Eseparator=$'\t' -e tcp.stream -e tcp.completeness.str -e ip.src -e tcp.srcport -e ip.dst -e tcp.dstport -e ipv6.src -e ipv6.dst | awk -F$'\t' 'function pick(a,b){return a!=""?a:b} function decode(f){r=f~/R/;fn=f~/F/;d=f~/D/;a=f~/A/;sa=substr(f,5,1)=="S";sn=substr(f,6,1)=="S";b=(sn&&sa&&a)?"Complete":(sn&&a)?"Established":sn?"Half-open":"Unknown";dt=(fn||r)?(d?"WITH_DATA_CLOSED":"NO_DATA_CLOSED"):(d?"WITH_DATA":"NO_DATA");return b", "dt} {s=$1;if(!(s in seen)){seen[s]=1;comp[s]=$2;dir[s]=pick($3,$7)":"$4" -> "pick($5,$8)":"$6}} END{for(s in comp){k=decode(comp[s])SUBSEP comp[s];cnt[k]++;list[k]=list[k](list[k]?"\n":"")dir[s]} PROCINFO["sorted_in"]="@ind_str_asc";for(k in cnt){split(k,p,SUBSEP);printf "[Status: %s] [Flags: %s] [Count: %d connections]\n%s\n\n",p[1],p[2],cnt[k],list[k]}}'::tcp-completeness.txt::tcp


# UDP 相关统计
tshark -r {INPUT} -q -z conv,udp::udp-conversations.txt::udp

# DNS 相关统计
tshark -r {INPUT} -q -z dns,tree::dns-general.txt::dns
tshark -r {INPUT} -q -z dns_qr,tree::dns-query-response.txt::dns

# TLS 相关统计
tshark -r {INPUT} -Y "tls.alert_message && tcp" -o tcp.desegment_tcp_streams:TRUE -o tcp.reassemble_out_of_order:TRUE -T fields -e ip.src -e tcp.srcport -e ip.dst -e tcp.dstport -e tls.alert_message.desc | awk '{desc=$5; pair=$1":"$2" -> "$3":"$4; cnt[desc]++; if(!seen[desc"|"pair]++) list[desc]=list[desc]"\n"pair} END{for(d in cnt) print "TLS Alert: " d " (count " cnt[d] "):" list[d] "\n"}'::tls-alert-message.txt::tls

# HTTP 相关统计
tshark -r {INPUT} -Y "http.response" -T fields -e ip.src -e tcp.srcport -e ip.dst -e tcp.dstport -e http.response.code | awk '{code=$5; pair=$1":"$2" -> "$3":"$4; a[code]=a[code]"\n"pair} END{for(i in a) print "Status "i":"a[i]"\n"}'::http-response-code.txt::http

# FTP 相关统计
tshark -r {INPUT} -Y 'ftp.response.code' -o tcp.desegment_tcp_streams:TRUE -o tcp.reassemble_out_of_order:TRUE -T fields -e ip.src_host -e tcp.srcport -e ip.dst_host -e tcp.dstport -e ftp.response.code -e ftp.response.arg | awk -F'\t' '{code=$5; msg=$6; pair=$1":"$2" -> "$3":"$4; key=code"|"msg; cnt[key]++; if(!seen[key"|"pair]++) list[key]=list[key]"\n  "pair} END{n=asorti(cnt,idx); for(i=1;i<=n;i++){split(idx[i],a,"|"); printf "FTP %s - %s (count %d):%s\n\n", a[1], a[2], cnt[idx[i]], list[idx[i]]}}'::ftp-response-code.txt::ftp

# ICMP 相关统计
tshark -r {INPUT} -Y icmp -T fields -e icmp.type -e icmp.code -e ip.proto -e ip.src -e tcp.srcport -e udp.srcport -e ip.dst -e tcp.dstport -e udp.dstport -E occurrence=l -E separator=, | awk -F',' 'BEGIN{d["0:0"]="Echo Reply";d["3:0"]="Net Unreachable";d["3:1"]="Host Unreachable";d["3:2"]="Protocol Unreachable";d["3:3"]="Port Unreachable";d["3:4"]="Fragmentation Needed";d["3:5"]="Source Route Failed";d["3:6"]="Net Unknown";d["3:7"]="Host Unknown";d["3:9"]="Net Prohibited";d["3:10"]="Host Prohibited";d["3:13"]="Communication Prohibited";d["4:0"]="Source Quench";d["5:0"]="Redirect Network";d["5:1"]="Redirect Host";d["8:0"]="Echo Request";d["9:0"]="Router Advertisement";d["10:0"]="Router Solicitation";d["11:0"]="TTL Exceeded";d["11:1"]="Fragment Reassembly Timeout";d["12:0"]="IP Header Error";d["13:0"]="Timestamp Request";d["14:0"]="Timestamp Reply";p[1]="ICMP";p[6]="TCP";p[17]="UDP";has_embed["3"]=1;has_embed["4"]=1;has_embed["5"]=1;has_embed["11"]=1;has_embed["12"]=1}{t=$1;c=$2;proto=$3;sip=$4;sport=$5?$5:$6;dip=$7;dport=$8?$8:$9;tc_key=t":"c;all_tc[tc_key]++;if(has_embed[t]&&sport!=""&&dport!=""){pname=p[proto]?p[proto]:"Proto"proto;k=t","c","pname","sip","sport","dip","dport;cc[k]++}else if(!has_embed[t]){simple_tc[tc_key]++}}END{if(length(cc)>0){print "ICMP error messages with embedded protocol info:\n";printf "%-30s %-8s %-40s %s\n","ICMP Type/Code","Protocol","Embedded 5-tuple","Count";print "--------------------------------------------------------------------------------------------";for(k in cc){split(k,a,",");tc=a[1]":"a[2];desc=d[tc]?d[tc]:"Type "a[1]" Code "a[2];label="["a[1]"/"a[2]"] "desc;tuple=a[4]":"a[5]" -> "a[6]":"a[7];printf "%-30s %-8s %-40s %s\n",label,a[3],tuple,cc[k]}}if(length(simple_tc)>0){if(length(cc)>0)print "";print "ICMP informational messages:\n";printf "%-30s %s\n","ICMP Type/Code","Count";print "-------------------------------------------";for(tc in simple_tc){split(tc,a,":");desc=d[tc]?d[tc]:"Type "a[1]" Code "a[2];label="["a[1]"/"a[2]"] "desc;printf "%-30s %s\n",label,simple_tc[tc]}}}'::icmp-messages.txt::icmp


